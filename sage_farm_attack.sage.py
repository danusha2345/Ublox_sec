

# This file was *autogenerated* from the file sage_farm_attack.sage
from sage.all_cmdline import *   # import sage library

_sage_const_10 = Integer(10); _sage_const_90 = Integer(90); _sage_const_120 = Integer(120); _sage_const_20 = Integer(20); _sage_const_30 = Integer(30); _sage_const_40 = Integer(40); _sage_const_50 = Integer(50); _sage_const_60 = Integer(60); _sage_const_0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF = Integer(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF); _sage_const_0xFFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831 = Integer(0xFFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831); _sage_const_0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC = Integer(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC); _sage_const_0x64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1 = Integer(0x64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1); _sage_const_0x188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012 = Integer(0x188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012); _sage_const_0x07192B95FFC8DA78631011ED6B24CDD573F977A11E794811 = Integer(0x07192B95FFC8DA78631011ED6B24CDD573F977A11E794811); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_100 = Integer(100); _sage_const_5 = Integer(5)#!/usr/bin/env sage
import csv
import hashlib
import os
import random as py_random
import time
import multiprocessing
from sage.all import *

# =============================================================================
# КОНФИГУРАЦИЯ
# =============================================================================
WORKERS = _sage_const_10            # Количество параллельных процессов
SUBSET_SIZE = _sage_const_90        # Размер решетки (достаточно для сильной утечки)
TOP_SIGS = _sage_const_120          # Берем только самые лучшие (концентрат)
BLOCK_SIZES = [_sage_const_20 , _sage_const_30 , _sage_const_40 , _sage_const_50 , _sage_const_60 ] # Этапы BKZ
# =============================================================================

# SECP192R1
p = _sage_const_0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF 
n = _sage_const_0xFFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831 
a = _sage_const_0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC 
b = _sage_const_0x64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1 
Gx = _sage_const_0x188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012 
Gy = _sage_const_0x07192B95FFC8DA78631011ED6B24CDD573F977A11E794811 

E = EllipticCurve(GF(p), [a, b])
G = E.point((Gx, Gy))
order = Integer(n)

def load_signatures():
    all_sigs = []
    filename = 'sigs_combined.csv' if os.path.exists('sigs_combined.csv') else 'sigs_new.csv'
    print(f"Загрузка из {filename}...")
    
    with open(filename, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            r = Integer(int(row['r']))
            all_sigs.append({
                'r': r,
                's': Integer(int(row['s'])),
                'z': Integer(int(row['z'])),
                'r_bits': r.nbits()
            })
    
    # Сортируем и берем топ
    all_sigs.sort(key=lambda x: x['r']) # ВКЛЮЧЕНО: Bias в r подтвержден FFT!
    print(f"Всего подписей: {len(all_sigs)}")
    print(f"Используем КОНЦЕНТРАТ из топ-{TOP_SIGS} лучших подписей")
    return all_sigs[:TOP_SIGS]

# Глобальная переменная для воркеров
sigs_pool = []

def worker_task(worker_id):
    # Инициализация RNG
    set_random_seed()
    
    # Выбираем случайное подмножество из ТОПА
    my_sigs = py_random.sample(sigs_pool, SUBSET_SIZE)
    
    # Строим решетку
    m = len(my_sigs)
    t_list = []
    u_list = []
    
    for sig in my_sigs:
        s_inv = inverse_mod(sig['s'], order)
        t_list.append((s_inv * sig['r']) % order)
        u_list.append((s_inv * sig['z']) % order)
    
    # Bound
    max_bits = max(s['r_bits'] for s in my_sigs)
    B = _sage_const_2 **(max_bits)
    
    rows = []
    for i in range(m):
        row = [_sage_const_0 ] * (m + _sage_const_2 )
        row[i] = B * order
        rows.append(row)
        
    rows.append([t_list[i] * B for i in range(m)] + [_sage_const_1 , _sage_const_0 ])
    rows.append([u_list[i] * B for i in range(m)] + [_sage_const_0 , B])
    
    M = Matrix(ZZ, rows)
    
    print(f"[W{worker_id}] Старт LLL (bits={max_bits})...")
    M.LLL()
    
    res = check_solution(M, m, B, t_list, u_list, my_sigs)
    if res: return res
    
    for block in BLOCK_SIZES:
        print(f"[W{worker_id}] Старт BKZ-{block}...")
        M.BKZ(block_size=block)
        res = check_solution(M, m, B, t_list, u_list, my_sigs)
        if res: return res
        
    print(f"[W{worker_id}] Неудача.")
    return None

def check_solution(M, m, B, t_list, u_list, sigs):
    for i in range(M.nrows()):
        row = M[i]
        if abs(abs(row[m+_sage_const_1 ]) - B) > B//_sage_const_100 : continue
        
        vec = row if row[m+_sage_const_1 ] > _sage_const_0  else -row
        d_cand = Integer(vec[m]) % order
        if d_cand == _sage_const_0 : continue
        
        k0 = (t_list[_sage_const_0 ] * d_cand + u_list[_sage_const_0 ]) % order
        if k0.nbits() <= sigs[_sage_const_0 ]['r_bits'] + _sage_const_5 :
            Pub = d_cand * G
            r0 = sigs[_sage_const_0 ]['r']
            w = inverse_mod(sigs[_sage_const_0 ]['s'], order)
            u1 = (sigs[_sage_const_0 ]['z'] * w) % order
            u2 = (r0 * w) % order
            P = u1*G + u2*Pub
            if (Integer(P[_sage_const_0 ]) % order) == r0:
                return d_cand
    return None

def main():
    global sigs_pool
    sigs_pool = load_signatures()
    
    print(f"Запуск {WORKERS} процессов...")
    pool = multiprocessing.Pool(processes=WORKERS)
    tasks = range(WORKERS * _sage_const_100 )
    
    for result in pool.imap_unordered(worker_task, tasks):
        if result:
            print(f"\n{'='*_sage_const_60 }")
            print(f"!!! КЛЮЧ НАЙДЕН !!!")
            print(f"Private Key: {hex(result)}")
            print(f"{'='*_sage_const_60 }")
            with open('FOUND_KEY_FARM.txt', 'w') as f:
                f.write(hex(result))
            pool.terminate()
            return
            
    print("Все попытки исчерпаны.")

if __name__ == '__main__':
    main()

